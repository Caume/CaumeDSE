diff --git a/crypto.c b/crypto.c
index 690f801adb89262673a2a08456d99572bd15e877..d5b88341f2c03673061119b2ea2310bee523d470 100644
--- a/crypto.c
+++ b/crypto.c
@@ -421,76 +421,59 @@ int cmePrngGetBytes (unsigned char **buffer, int num)
         if(!result) //Error
         {
 #ifdef ERROR_LOG
             fprintf(stderr,"CaumeDSE Error: cmePrngGetBytes(), Error geting random bytes with"
                 " RAND_bytes()!\n");
 #endif
             return(1);
         }
 #ifdef DEBUG
         fprintf(stdout,"CaumeDSE Debug: cmePrngGetBytes(), obtained %d bytes from PRNG.\n",num);
 #endif
         return(0);
     }
     else
     {
 #ifdef ERROR_LOG
         fprintf(stderr,"CaumeDSE Error: cmePrngGetBytes(), malloc() error allocating buffer for"
                 " %d pseudo random bytes!\n", num);
 #endif
         return(255);
     }
 }
 
 int cmeGetRndSalt (char **rndHexSalt)
 {
-    char *rndBytes=NULL;
+    char *rndBytes = NULL;
 
-    cmePrngGetBytes((unsigned char **)&rndBytes,cmeDefaultIDBytesLen);  //Get random bytes for salt
-    int isGCM=0;
-    unsigned char tag[16];
-    if (strstr(algorithm, "gcm"))
-        isGCM=1;
-    int allocExtra = (isGCM && mode=='e') ? 16 : 0;
-    int inputLen = srcLen;
-    if(isGCM && mode=='d')
-        inputLen = srcLen - 16;
-    if(!(*dstBuf=(unsigned char *)malloc(inputLen+cipherBlockLen+allocExtra+1))) //Error allocating memory!
-    memset(*dstBuf,0,inputLen+cipherBlockLen+allocExtra+1); //clear destination buffer
-        if(isGCM && mode=='d')
-            memcpy(tag, srcBuf+inputLen, 16);
-        cmeCipherUpdate(ctx,(*dstBuf),&written,(unsigned char *)srcBuf,inputLen,mode);
-        if(isGCM && mode=='d')
-            EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, 16, tag);
-        if(isGCM && mode=='e' && result==0){
-            if(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, 16, tag)){
-                memcpy((*dstBuf)+cont, tag, 16);
-                cont += 16;
-            } else {
-                exitcode=8;
-            }
-        }
+    /* Obtain random bytes for the salt and return them as a hex string. */
+    cmePrngGetBytes((unsigned char **)&rndBytes, cmeDefaultIDBytesLen);
+    cmeBytesToHexstr((const unsigned char *)rndBytes,
+                     (unsigned char **)rndHexSalt,
+                     cmeDefaultIDBytesLen); /* caller must free rndHexSalt */
+    cmeFree(rndBytes);
+    return (0);
 }
 
 int cmeGetRndSaltAnySize (char **rndHexSalt, int size)
 {
     char *rndBytes=NULL;
 
     cmePrngGetBytes((unsigned char **)&rndBytes,size);  //Get random bytes for salt
     cmeBytesToHexstr((const unsigned char *)rndBytes,(unsigned char **)rndHexSalt,size); //Note that caller must free rndHexSalt!
     cmeFree(rndBytes);
     return (0);
 }
 
 int cmeCipherByteString (const unsigned char *srcBuf, unsigned char **dstBuf, unsigned char **salt,
                          const int srcLen, int *dstWritten, const char *algorithm, const char *ctPassword,
                          const char mode)
 {
     int result;
     int cont=0;
     int exitcode=0;
     int written=0;
     int cipherBlockLen=0;
     int keyLen=0;
     int ivLen=0;
     unsigned char *key=NULL;
     unsigned char *iv=NULL;
diff --git a/db.c b/db.c
index c6897085ed8cbebfe0c325190daf46df1247cc47..c2d30e5539214c9ae026dcc25fcaf7242f41deeb 100644
--- a/db.c
+++ b/db.c
@@ -2125,61 +2125,51 @@ int cmeMemTableWithTableColumnNames (sqlite3 *db, const char *tableName)
     #define cmeMemTableWithTableColumnNamesFree() \
         do { \
             cmeFree(sqlQuery); \
         } while (0); //Local free() macro.
         //Note: results will be located in cmeResultMemTable by pointing it to tmpColumnMemTable (we don't free tmpColumnMemTable).
 
     cmeResultMemTableClean();
     cmeStrConstrAppend(&sqlQuery,"PRAGMA table_info(\"%s\");",tableName);
     result=cmeSQLRows(db,(const char *) sqlQuery,NULL,NULL); //Select all data; no parser script.
     numCols=cmeResultMemTableRows;
     if (numCols)
     {
         tmpColumnMemTable=(char **)malloc(sizeof(char *)*numCols); //Reserve memory for column names;
     }
     for (cont=0;cont<numCols;cont++)
     {
         tmpColumnMemTable[cont]=NULL;
         cmeStrConstrAppend(&(tmpColumnMemTable[cont]),"%s",cmeResultMemTable[cmeResultMemTableCols*(cont+1)+columnNameIndex]); //We skip headers in resultMemTable
     }
     cmeResultMemTableClean();
     cmeResultMemTable=tmpColumnMemTable;
     cmeResultMemTableCols=numCols;
     cmeResultMemTableRows=0;
     cmeMemTableWithTableColumnNamesFree();
     return (0);
-            char *tmpPtr = (char *)realloc(*sanitizedString, sizeof(char)*(sanitizedStringLen+1));
-            if(!tmpPtr)
-            {
-#ifdef ERROR_LOG
-                fprintf(stderr,"CaumeDSE Error: cmeSanitizeStrForSQL(), realloc() out of memory!\n");
-#endif
-                cmeFree(*sanitizedString);
-                *sanitizedString=NULL;
-                return(2);
-            }
-            *sanitizedString = tmpPtr; //Add 1 character to the sanitized string.
+}
 
 int cmeSanitizeStrForSQL (const char *sourceString, char **sanitizedString)
 {
     int cont,cont2;
     int sourceStringLen=0;
     int sanitizedStringLen=0;
 
     if (!sourceString) //Error, source string can't be NULL
     {
 #ifdef ERROR_LOG
         fprintf(stderr,"CaumeDSE Error: cmeSanitizeStrForSQL(), Error, source string can't be NULL!\n");
 #endif
         return(1);
     }
     sourceStringLen=strlen(sourceString);
     sanitizedStringLen=sourceStringLen;
     *sanitizedString=(char *)malloc(sizeof(char)*(sanitizedStringLen+1)); //Set length of sanitized string = length of source string to start.
     cont2=0;
     for (cont=0;cont<sourceStringLen;cont++)
     {
         if (sourceString[cont]=='\'') //If we find a single quote character, we double it in the sanitized string.
         {
             (*sanitizedString)[cont2]='\'';
             cont2++;
             sanitizedStringLen++;
